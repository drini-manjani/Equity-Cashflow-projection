import os
import pandas as pd

# -----------------------------
# Helpers
# -----------------------------

def add_quarters(qe: pd.Timestamp, q: int) -> pd.Timestamp:
    if pd.isna(qe):
        return pd.NaT
    p = pd.Period(qe, freq="Q")
    return (p + int(q)).to_timestamp("Q")


def _norm_col(c):
    if not isinstance(c, str):
        return c
    return " ".join(c.strip().split())


def _norm_key(s: str) -> str:
    return " ".join(s.strip().lower().replace("_", " ").split())


# -----------------------------
# Inputs
# -----------------------------

year = int(input("Enter year (e.g. 2025): ").strip())
quarter = input("Enter quarter (Q1, Q2, Q3, Q4): ").strip().upper()

# Termination rule: fund is terminated if last observed quarter_end >= planned_end_qe (+ grace)
END_GRACE_Q = int(input("Termination grace quarters (0 => none): ").strip() or "0")

BASE_DIR = os.environ.get(
    "EQUITY_BASE_DIR",
    os.path.join("C:", "Users", os.environ.get("USERNAME", ""), "Documents", "Equity")
)
if not os.path.exists(BASE_DIR):
    BASE_DIR = os.path.abspath(os.getcwd())

HOME = os.path.join(BASE_DIR, f"{year}_{quarter}")
DATA_DIR = os.path.join(HOME, "data")

# Load data
parquet_path = os.path.join(DATA_DIR, "data.parquet")
csv_path = os.path.join(DATA_DIR, "data.csv")
if os.path.exists(parquet_path):
    data = pd.read_parquet(parquet_path)
elif os.path.exists(csv_path):
    data = pd.read_csv(csv_path)
else:
    raise FileNotFoundError(f"Missing data.parquet or data.csv in {DATA_DIR}")

# Normalize column names (trim/collapse spaces)
data.columns = [_norm_col(c) for c in data.columns]

# Required columns
req = [
    "FundID",
    "Adj Drawdown EUR",
    "Year of Transaction Date",
    "Quarter of Transaction Date",
    "Planned end date with add. years as per legal doc",
]
missing = [c for c in req if c not in data.columns]
if missing:
    raise ValueError(f"Missing required columns: {missing}")

# Commitment column aliases
col_by_key = {_norm_key(c): c for c in data.columns if isinstance(c, str)}
commit_level_col = None
commit_flow_col = None
for c in ["Commitment_Level", "Commitment Level", "commitment level"]:
    key = _norm_key(c)
    if key in col_by_key:
        commit_level_col = col_by_key[key]
        break
for c in ["Commitment EUR", "Commitment", "commitment eur", "commitment"]:
    key = _norm_key(c)
    if key in col_by_key:
        commit_flow_col = col_by_key[key]
        break
if commit_level_col is None and commit_flow_col is None:
    raise ValueError("Missing commitment column: expected one of Commitment_Level / Commitment Level / Commitment EUR / Commitment")

# Parse quarterly dates
q_year = pd.to_numeric(data["Year of Transaction Date"], errors="coerce")
q_qtr = pd.to_numeric(data["Quarter of Transaction Date"], errors="coerce")
if q_year.isna().any() or q_qtr.isna().any():
    raise ValueError("Year/Quarter of Transaction Date contains non-numeric values.")

data["quarter_end"] = pd.PeriodIndex(
    q_year.astype(int).astype(str) + "Q" + q_qtr.astype(int).astype(str),
    freq="Q"
).to_timestamp("Q")

data["planned_end_qe"] = pd.to_datetime(
    data["Planned end date with add. years as per legal doc"],
    errors="coerce"
).dt.to_period("Q").dt.to_timestamp("Q")

# Fund-level last observed quarter
last_obs = data.groupby("FundID", as_index=False)["quarter_end"].max().rename(columns={"quarter_end": "last_qe"})

# Fund-level planned end date (use last non-null)
plan = (data.dropna(subset=["planned_end_qe"])
            .sort_values(["FundID", "planned_end_qe"])
            .groupby("FundID", as_index=False)["planned_end_qe"].last())

funds = last_obs.merge(plan, on="FundID", how="left")

# Apply grace
funds["planned_end_qe_adj"] = funds["planned_end_qe"].apply(lambda x: add_quarters(x, END_GRACE_Q))

# Terminated if last observed >= planned end (with grace)
funds["terminated"] = (funds["planned_end_qe_adj"].notna()) & (funds["last_qe"] >= funds["planned_end_qe_adj"])
terminated_ids = funds.loc[funds["terminated"], "FundID"].tolist()

# Commitment per fund
if commit_level_col is not None:
    data["Commitment_Level"] = pd.to_numeric(data[commit_level_col], errors="coerce")
    commitment_by_fund = data.groupby("FundID")["Commitment_Level"].max()
    commit_source = "level_max"
else:
    data["Commitment_Flow"] = pd.to_numeric(data[commit_flow_col], errors="coerce")
    commitment_by_fund = data.groupby("FundID")["Commitment_Flow"].sum()
    commit_source = "flow_sum"

# Totals from historical data only
totals = (data.groupby("FundID", as_index=False)
          .agg(draw_total=("Adj Drawdown EUR", "sum")))

out = totals.merge(commitment_by_fund.rename("commitment_total"), on="FundID", how="left")
out = out.merge(funds[["FundID", "last_qe", "planned_end_qe", "planned_end_qe_adj", "terminated"]],
                on="FundID", how="left")

out = out[out["FundID"].isin(terminated_ids)].copy()
out["commitment_total"] = out["commitment_total"].fillna(0.0)
out["draw_total"] = out["draw_total"].fillna(0.0)
out["draw_to_commit"] = out.apply(
    lambda r: (r["draw_total"] / r["commitment_total"]) if r["commitment_total"] > 0 else 0.0, axis=1
)

summary = pd.DataFrame([{
    "FundID": "ALL_TERMINATED",
    "draw_total": out["draw_total"].sum(),
    "commitment_total": out["commitment_total"].sum(),
    "draw_to_commit": (out["draw_total"].sum() / out["commitment_total"].sum())
                      if out["commitment_total"].sum() > 0 else 0.0,
    "last_qe": pd.NaT,
    "planned_end_qe": pd.NaT,
    "planned_end_qe_adj": pd.NaT,
    "terminated": True,
}])

out = pd.concat([out, summary], ignore_index=True)

# Save
out_csv = os.path.join(DATA_DIR, "terminated_drawdowns_vs_commitment.csv")
out_pq = os.path.join(DATA_DIR, "terminated_drawdowns_vs_commitment.parquet")
out.to_csv(out_csv, index=False)
out.to_parquet(out_pq, index=False)

print("Commitment source:", commit_source)
print("Terminated funds:", len(out) - 1)
print("Saved:")
print(out_csv)
print(out_pq)
